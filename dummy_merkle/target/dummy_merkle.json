{"noir_version":"1.0.0-beta.6+e796dfd67726cbc28eb9991782533b211025928d","hash":"9871566296763874384","abi":{"parameters":[{"name":"root","type":{"kind":"field"},"visibility":"public"},{"name":"proof","type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"},{"name":"item","type":{"kind":"field"},"visibility":"public"},{"name":"idx","type":{"kind":"array","length":4,"type":{"kind":"boolean"}},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"H4sIAAAAAAAA/9WY626DMAyFza0tW9et69bLeImYSwn/9ipDo+//CMOaK6GJ/eIEBUuR2wgdxbHPJ0RAv5H166S/g35Fmleah3vrkb3NyF6qmQb5U7OZFix6Sb9CrG6eDLQKcy3Lrs47LvjL5E1rK1NW7dWy5cpW37ktis6Wtm7apjYNl0XHt6opbir2gDuXoUH8rXnqOVdArUdgj5c0NwHwDrczzY2ZFhwCa34C9sJFreIRoJ9ZfLIdme+p97gDzw7af9LnnYO6n2kZrF0DtV7Ib9aG2ms0a5Hc2c80N2ZacASs+ZX8Zq14BOhnFp/sCc+cA/nNWunzwUHdb7QM1m6AWu/kN2sj7TWatUjuHGeaGzMtOAbWfCK/WSseAfqZxSdHwjPnTH6zVvp8dlD3hZbB2hSo9UF+szbWXqNZi+ROBp4bF/NyAc9M5qDXQC0jZ4tV657lu4K87wqHU/1/j0DvPdLnE/o/fgBhLFcXyBUAAA==","debug_symbols":"pZPBboQgEIbfhbMHBlmBfZWmMai4ISFoWG3SGN+9yEi7HuzBvcwvjN/PTGAW0plmftTW98OT3D8W0gTrnH3Ubmj1ZAcfd5e1IHlZT8GYuEVe8pEadTB+Inc/O1eQL+3m9NNz1D7ppEPM0oIY30WNhr11Zvtaiz+anqOKix1WqvrFb0cezvmK58MrfokXt8wLdYEXoHZecHnG83O+lGznSyku8ZB5xa7UL+TOS3p6vnizfvFm/f+8H6CQCwBalgeHz7jSrQ2HN094vOqC3FKsUhQpyhRVikBRAIWhlChoAOgAaAHoAWgC6MLQhaELY1uJ69ZKsLpxZp/Afvbty0BO32PO5JEdw9Cabg5mayTlYms/","file_map":{"50":{"source":"use poseidon::poseidon::bn254;\n\npub trait BinaryHasher<F> {\n    fn hash(a: F, b: F) -> F;\n}\n\nstruct Poseidon;\n\nimpl BinaryHasher<Field> for Poseidon {\n    fn hash(a: Field, b: Field) -> Field {\n        bn254::hash_2([a, b])\n    }\n\n}\n\nstruct DummyHasher;\n\n\nstruct x {\n    x : &mut u32\n}\n\nimpl BinaryHasher<Field> for DummyHasher {\n    fn hash(a: Field, b: Field) -> Field {\n        (a + 2) * b // Simple addition as a placeholder for hashing\n    }\n}\n\npub fn mtree_recover<H, let N: u32>(idx: [bool; N], p: [Field; N], item: Field) -> Field\nwhere\n    H: BinaryHasher<Field>,\n{\n    let mut curr_h = item;\n    for i in 0..N {\n        let dir = idx[i];\n        let sibling_root = p[i];\n        curr_h = if dir {\n            H::hash(sibling_root, curr_h)\n        } else {\n            H::hash(curr_h, sibling_root)\n        }\n    }\n    curr_h\n}\n\nfn main(root: pub Field, proof: pub [Field; 4], item: pub Field, idx: [bool; 4]) {\n    let calculated_root = mtree_recover::<DummyHasher, _>(idx, proof, item);\n    assert_eq(root, calculated_root);\n    // assert(root != item)\n}\n","path":"/Users/marcinkostrzewa/code/spartan-vm/dummy_merkle/src/main.nr"}},"names":["main"],"brillig_names":[]}